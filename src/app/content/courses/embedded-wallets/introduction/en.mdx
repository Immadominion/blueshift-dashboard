import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Embedded Wallets

![Embedded Wallets](/graphics/course-banners/embedded-wallets.png)

Traditional wallets demand perfect custody. Users must download a separate app, record a 24-word seed phrase, understand that any mistake means permanent fund loss, and then navigate wallet connection flows. Mobile Wallet Adapter improves the connection step but still requires this upfront burden.

Mobile users expect apps to work immediately. A crypto app that demands external wallet setup before showing any functionality introduces friction at the exact moment engagement matters most. Embedded wallets remove this barrier by handling key management invisibly while users authenticate through patterns they already trust: FaceID, Google accounts, email verification.

Embedded wallets remove this friction. The wallet lives inside your application as invisible infrastructure. Users authenticate with FaceID or Google accounts. The private key is split across multiple parties using MPC, stored in hardware security modules, or controlled by smart contract logic. No seed phrases. No separate apps. Just authentication that works.

Modern MPC and passkey-based embedded wallets distribute the attack surface. An attacker must compromise multiple independent systems simultaneously, whereas a seed phrase written on paper has a single point of failure.

<ArticleSection name="The Problem with Traditional Wallets" id="the-problem-with-traditional-wallets" level="h2" />

Traditional wallet onboarding requires users to download a wallet app, write down a 24-word seed phrase, understand that losing it means permanent fund loss, and then connect the wallet to your application. Mobile Wallet Adapter improves the connection experience but still requires this multi-step setup.

Most mobile users expect apps to work immediately after installation. External wallet configuration introduces friction at the moment when you need users most engaged. Embedded wallets remove this friction by handling key management transparently while users authenticate through patterns they already trust.

The tradeoff: users trust your application's wallet infrastructure rather than managing keys themselves. For crypto-native users who understand and prefer self-custody, external wallets remain the better choice. For mainstream users unfamiliar with blockchain, embedded wallets remove barriers that would otherwise prevent adoption.

### The UX Hierarchy

Users want wallets that sign transactions when needed and remain invisible otherwise. The wallet should be infrastructure, not interface. If something breaks, recovery should work without catastrophic loss.

Traditional wallets invert this hierarchy. They make the wallet the central experience, demand constant attention, and punish any mistake with permanent fund loss.

<ArticleSection name="What is an Embedded Wallet?" id="what-is-an-embedded-wallet" level="h2" />

An embedded wallet is a cryptographic key pair managed programmatically by a service or SDK, authenticated through familiar methods like email, social login, or biometrics. The private key is either:

- **Split across multiple parties** using MPC (Multi-Party Computation)
- **Stored in hardware security modules** (passkeys via device secure enclave)
- **Controlled by smart contract logic** (PDAs with flexible authorization)

From the user's perspective, they log in with their phone's FaceID or their Google account. Behind the scenes, this authentication grants access to sign transactions with a Solana keypair.

This approach eliminates onboarding friction: users authenticate with patterns they already know rather than learning new key management procedures. There's no seed phrase to write down or lose. The wallet lives inside your application rather than requiring external dependencies. Recovery mechanisms can be programmable—social recovery, backup authentication factors, or institutional custody options—rather than the single point of failure that seed phrases represent.

<ArticleSection name="Four Approaches to Key Security" id="four-approaches" level="h2" />

Embedded wallet providers use fundamentally different cryptographic approaches. Understanding these architectures matters more than understanding any specific SDK.

### Multi-Party Computation (MPC)

MPC eliminates the single point of failure by splitting the private key into shares distributed across multiple parties. No single party ever holds the complete key.

```
+------------------+        +------------------+
|   User Device    |        |  Provider HSMs   |
|   (Share A)      |        |   (Share B)      |
+------------------+        +------------------+
         |                           |
         +---- Threshold Signing ----+
                      |
              +----------------+
              | Valid Signature|
              +----------------+
```

To sign a transaction, shares collaborate through cryptographic protocols that produce valid signatures without ever reconstructing the original key. An attacker must compromise multiple independent systems simultaneously.

From the developer's perspective, MPC providers abstract this complexity:

```typescript
// Privy: MPC shares coordinate behind the scenes
const { wallets } = useEmbeddedSolanaWallet();
const provider = await wallets[0].getProvider();
await provider.request({ method: 'signAndSendTransaction', params: { transaction } });
```

**Providers using MPC:** Privy, Dynamic, Para, Web3Auth

### Trusted Execution Environment (TEE/HSM)

TEE providers store the complete private key in specialized hardware: either server-side HSMs (Hardware Security Modules) or client-side secure enclaves. The key exists in one place, but that place is cryptographically isolated from the rest of the system.

```
+----------------+     +-------------------+
|  User Auth     |     |  Provider TEE     |
|  (OAuth/Email) |---->|  (HSM/SGX)        |
+----------------+     +-------------------+
                              |
                       [Isolated Enclave]
                       Key exists here only
                              |
                       +----------------+
                       | Sign & Return  |
                       +----------------+
```

The tradeoff: you trust the provider's hardware isolation rather than distributing trust across parties. The advantage: simpler architecture, faster signing, and often battle-tested infrastructure from established players.

**Providers using TEE/HSM:** Phantom Connect, Magic Link, Turnkey

### Passkey-Native

Passkeys use your device's secure enclave to hold the private key. The key never leaves hardware. FaceID or fingerprint gates access. On-chain programs verify passkey signatures directly using Solana's secp256r1 precompile.

```
+----------------+     +-------------------+     +-----------------+
|  User Device   |     |  Solana Program   |     |  Smart Wallet   |
|  (Passkey)     |---->|  (Verifier)       |---->|  (PDA)          |
+----------------+     +-------------------+     +-----------------+
      |
  [Secure Enclave]
  Key never leaves
```

The passkey signature IS the blockchain authorization. No provider infrastructure in the signing path.

```typescript
// LazorKit: Passkey triggers device biometric, signs on-chain
const { signAndSendTransaction } = useWallet();
await signAndSendTransaction(
  { instructions, transactionOptions: { feeToken: USDC_ADDRESS } },
  { redirectUrl: 'myapp://callback' }
);
```

**Providers using passkeys:** LazorKit

### Modular Signers

Some providers offer smart wallets that can be controlled by multiple signer types: passkeys, email authentication, social login, external wallets, or API keys.

```
Smart Wallet (PDA)
├── Primary: Passkey (user's phone)
├── Backup: Email (recovery)
└── Admin: API Key (automation)
```

This flexibility lets applications adapt authentication to different user segments and use cases.

**Providers using modular signers:** Crossmint

<ArticleSection name="The Provider Landscape" id="the-provider-landscape" level="h2" />

Providers implement these architectures in different combinations. Understanding which architecture a provider uses matters more than comparing feature lists.

### When Distributed Trust Matters (MPC)

MPC providers split keys between user devices and provider infrastructure. No single party holds the complete key. Multiple backup options exist because shares can be stored independently. Key export is sometimes possible by reconstructing shares.

Providers using MPC include **Privy** (2-of-2 MPC with hybrid embedded + MWA support), **Dynamic** (TSS-FROST with native Ed25519 and key export), **Para** (distributed MPC across Solana, EVM, and Cosmos), and **Web3Auth** (Torus network MPC with extensive customization).

Choose MPC when you need distributed trust, want multiple recovery options, or may need key portability. The tradeoff: slightly higher signing latency due to coordination between parties.

### When Provider Infrastructure Can Be Trusted (TEE/HSM)

TEE/HSM providers store complete keys in hardware-isolated enclaves. Simpler architecture than MPC, with faster signing. Users trust the provider's hardware security rather than distributing trust across parties.

Providers using TEE/HSM include **Turnkey** (bring-your-own-auth with maximum developer control), **Phantom Connect** (OAuth with Google/Apple, includes transaction simulation users already trust), and **Magic** (Fortanix SGX with passwordless email/SMS authentication).

Choose TEE/HSM when simplified architecture is preferred, provider trust is acceptable, or signing speed matters. Recovery is provider-managed rather than user-controlled.

### When Minimum Trust Assumptions Required (Passkey-Native)

Passkey providers store keys in device secure enclaves with no provider in the signing path. The private key never leaves hardware. Smart wallets verify passkey signatures on-chain using Solana's secp256r1 precompile.

Providers using passkeys include **LazorKit** (passkey-only smart wallets with built-in paymaster).

Choose passkeys when provider infrastructure should not be in the critical path, users have passkey-capable devices, or transaction fees can be sponsored via paymaster.

### When Flexibility Matters (Modular Signers)

Modular providers let multiple authentication methods control the same smart wallet. Users can start with email, add a passkey later, and configure recovery through social connections. Security can evolve as users become more sophisticated.

Providers using modular signers include **Crossmint** (passkey, email, social, external wallet, and API key signers for the same smart wallet).

Choose modular signers when different user segments need different auth methods, security requirements may evolve, or you want to support progressive security upgrades.

<ArticleSection name="When to Consider Alternatives" id="when-alternatives" level="h2" />

Embedded wallets work best for applications with frequent signing operations like games, social tipping, or DeFi protocols serving non-crypto-native users. They excel when gas sponsorship matters for onboarding flows, or when recovery must be seamless without seed phrase backups.

External wallets through MWA remain better for crypto-native users who prefer existing wallet management, applications that are read-heavy with rare signing needs, or contexts where maximum decentralization is required. Some users distrust any third-party involvement in key management and will always prefer self-custody.

Hybrid implementations serve both audiences. Users can start with embedded wallets for immediate access, then optionally connect external wallets if they prefer self-custody as they become more sophisticated. This approach provides optionality rather than forcing a single authentication model.

<ArticleSection name="Course Structure" id="course-structure" level="h2" />

This course teaches the cryptographic foundations of embedded wallets, not SDK tutorials. APIs change. Concepts endure.

| Lesson | Topic |
|--------|-------|
| 1 | Introduction (you are here) |
| 2 | MPC Cryptography: How threshold signatures eliminate single points of failure |
| 3 | Passkeys and WebAuthn: How hardware security modules protect keys |
| 4 | Smart Wallet Architectures: PDAs, account abstraction, and programmable security |
| 5 | Choosing Your Approach: Decision framework based on your requirements |

After completing this course, you'll understand:
- Why MPC is more secure than a single key
- How passkeys provide phishing-proof authentication
- What makes smart wallets "programmable"
- How to evaluate providers based on architecture, not marketing

### Prerequisites

- Completed the Mobile Wallet Adapter course (or equivalent knowledge)
- Understanding of Solana accounts and transactions
- Basic familiarity with public key cryptography

**Relationship to Course 1:** The Mobile Wallet Adapter course covers external wallet connections where users control their own keys through apps like Phantom or Solflare. This course covers embedded wallets where your application manages keys through third-party infrastructure. Many production apps implement both: embedded wallets for <1s wallet creation without seed phrases, with an option to connect external wallets for users who prefer self-custody. The on-chain operations from Course 3 work identically with either wallet type—only the signing mechanism differs.

**Note:** Passkey functionality requires real device testing. Emulators do not have access to device secure enclaves.

The next lesson examines how MPC eliminates the fundamental vulnerability in traditional key storage.
