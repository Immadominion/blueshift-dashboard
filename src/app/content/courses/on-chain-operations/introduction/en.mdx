import { ArticleSection } from "../../../../../components/ArticleSection/ArticleSection";

# Introduction to On-Chain Operations

A user initiates a token transfer. The network drops mid-request. The transaction may have succeeded, failed, or still be processing. Your app must handle this ambiguity without confusing the user or double-spending.

Desktop developers assume stable connections. Mobile cannot. Networks drop. Batteries die. Small screens prevent displaying full transaction details. These constraints demand different architectures: retry logic that doesn't duplicate operations, caching strategies that preserve battery life, and UI that presents complex blockchain state clearly on limited screens.

This course covers on-chain operations—token transfers, NFT handling, program interaction—with mobile constraints as first-class concerns. Every pattern accounts for unreliable networks, battery constraints, and limited screen space.

<ArticleSection name="What You'll Learn" id="what-youll-learn" level="h2" />

Mobile RPC differs from web RPC in three critical ways. Connections drop mid-request, requiring retry logic and offline state handling. Constant polling drains batteries—websockets and smart caching reduce network activity while keeping data fresh. Small screens can't display transaction details like desktop block explorers, demanding careful information hierarchy. You'll set up reliable connections on unreliable networks, implement battery-efficient caching strategies, and choose RPC providers optimized for production mobile apps.

SPL tokens power Solana DeFi. You'll fetch token balances with proper caching, build transfer flows with mobile-optimized UX, manage Associated Token Accounts automatically, and display metadata from various token standards. Every operation accounts for mobile constraints: small screens, intermittent connectivity, and battery life.

NFT operations require special handling for media, metadata, and collections. You'll fetch NFT collections efficiently without overwhelming mobile memory, display NFT media (images, video, 3D models) with proper loading states, implement transfer and burn operations with clear user feedback, and work with Metaplex standards for both Token Metadata and Core.

Solana Actions and Blinks bring blockchain interactions to any surface—social media posts, QR codes, or messaging apps. This course covers understanding the Actions specification, building mobile-native Action clients, rendering Blinks in your app with proper security warnings, and evaluating security considerations for external Actions before executing them.

Direct program interaction gives you full control over on-chain operations. This course covers building and signing arbitrary instructions for custom programs, working with Anchor IDLs on mobile to generate type-safe instructions, using transaction simulation to prevent failed transactions by showing users exact state changes before they sign, and implementing error handling with retry strategies that survive poor network conditions.

<ArticleSection name="Prerequisites" id="prerequisites" level="h2" />

Before starting this course, you should have:

1. **Completed Course 1 (Mobile Wallet Adapter)** or **Course 2 (Embedded Wallets)** - Understanding wallet connections and transaction signing
2. **Experience with `@solana/web3.js`** (or willingness to learn from code examples)

Whether you connected via MWA (Course 1) or embedded wallets (Course 2), the on-chain operations in this course work identically. Transaction building uses the same `@solana/web3.js` APIs regardless of wallet type. Only the signing mechanism differs—MWA's `wallet.signAndSendTransactions()` or embedded wallet provider methods. The RPC calls, instruction building, and account fetching remain consistent across both approaches.

Course 4 (MWA Deep Dive) is optional and helps debug connection issues, but the concepts here focus on what happens *after* wallet authorization.

<ArticleSection name="Mobile-First Mindset" id="mobile-first" level="h2" />

Every lesson in this course considers mobile constraints that don't exist on desktop.

Mobile connections drop mid-request, requiring retry logic and offline state handling. Constant RPC polling drains batteries; websockets and smart caching reduce network activity while keeping data fresh. Small screens can't display transaction details like desktop block explorers, demanding careful information hierarchy.

Users expect instant feedback. Optimistic updates, clear loading states, and transaction status tracking prevent the perception of slowness even when network latency is unavoidable.

<ArticleSection name="Development Setup" id="development-setup" level="h2" />

You'll need:

- React Native or Expo project with MWA configured
- Android device or emulator for testing
- Wallet app installed (Phantom or Solflare)
- Devnet SOL for testing transactions

If you completed the Mobile Wallet Adapter course, your environment is ready.

<ArticleSection name="Course Structure" id="course-structure" level="h2" />

Each lesson builds on the previous:

1. **RPC Fundamentals** - Connection setup, commitment levels, and mobile optimizations
2. **Token Operations** - SPL token transfers, balances, and metadata
3. **NFT Operations** - Collections, media handling, and NFT transfers
4. **Blinks and Actions** - Solana Actions specification and mobile implementation
5. **Program Interaction** - Building custom instructions and working with Anchor

By the end, you'll have the skills to build feature-rich mobile dApps that interact with any Solana program.

Start with RPC Fundamentals to understand how your mobile app communicates with the Solana network. This foundation supports everything else you build.
